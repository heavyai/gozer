{"version":3,"file":"index.js","sources":["../node_modules/fast-deep-equal/index.js","../src/utils/deepDiffDebug.js","../src/utils/sanitizeObject.js","../src/components/Zuul.js","../src/utils/deepWalkDebug.js","../src/middleware/vinzclortho.js"],"sourcesContent":["'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","/*\n  Why is your component re-rendering? Just WTF actually changed in your props?\n\n  Use this handy dandy debug function to find out!\n\n  Sample usage:\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.props.id === \"1\") {\n      outputDeepDiff( deepDiffDebug(nextProps, this.props), { filter : /fetchRangeData/ } )\n    }\n    return true;\n  }\n\n  Note that it's restricting the diff to only a particular ID (so we don't dump it out for everything),\n  and that it's specifying a matching regex to only print out diffs on the fetchRangeData function.\n\n  Change those values as necessary.\n\n  And figure out what's changed and skip those unnecessary re-render cycles.\n\n*/\n\n/*\n  deepDiffDebug( obj1, obj2 )\n\n  returns a data structure with a list of all differences between obj1 and obj2.\n\n  The return is an array of differences:\n    {\n      key,\n      type,\n      leftLabel,\n      leftValue,\n      rightLabel,\n      rightValue\n    }\n\n  The \"key\" is an array which contains the key path to reach the diff in the structure.\n  So if the difference is at obj[\"a\"][\"b\"][\"c\"] the key will be [\"a\", \"b\", \"c\"]\n\n  \"type\" is either \"ref\", \"val\", or \"ref/val\" so you can filter looking at differences which have\n  a value difference or a ref difference.\n\n  \"ref\" means that the objects are identical, but different references.\n  \"val\" means that the values are different, e.g. 2 !== 3\n  \"ref/val\" means that the objects are not identical AND there are values contained within them\n    which do not match.\n\n  leftLabel, leftValue are the pretty display label and actual object in obj1 at the\n  given key path.\n\n  rightLabel, rightValue are the pretty display label and actual object in obj2 at the\n  given key path.\n\n  Read on to see additional functions to help you deal with this output.\n*/\n\nexport function deepDiffDebug(a, b, key = []) {\n  const output = []\n  // the refRow is output if two objects or arrays are not the same ref.\n  // if the refs are different but all values the same, it'll be of type ref\n  // if the values differ too, it'll be ref/val.\n  const refRow = {\n    key,\n    leftLabel: \"left ref\",\n    leftValue: a,\n    rightLabel: \"right ref\",\n    rightValue: b,\n    type: \"ref\"\n  }\n\n  if (a === null && b === null) {\n    // both nulls? DO NOTHING\n  } else if (a === b) {\n    // both referentially equal? DO NOTHING\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    output.push(refRow)\n    a.forEach((e, i) => {\n      const subOutput = deepDiffDebug(a[i], b[i], [...key, i])\n      output.push(...subOutput)\n      if (diffsByTypes(subOutput, [\"val\", \"ref/val\"]).length) {\n        refRow.type = \"ref/val\"\n      }\n    })\n    if (b.length > a.length) {\n      for (let i = a.length; i < b.length; i = i + 1) {\n        const subOutput = deepDiffDebug(undefined, b[i], [...key, i])\n        if (diffsByTypes(subOutput, [\"val\", \"ref/val\"]).length) {\n          refRow.type = \"ref/val\"\n        }\n      }\n    }\n  } else if (\n    objectType(a) === \"object\" &&\n    objectType(b) === \"object\" &&\n    a !== null &&\n    b !== null\n  ) {\n    output.push(refRow)\n    Object.keys(a)\n      .filter(objKey => objKey !== \"containerRef\")\n      .sort()\n      .forEach(objKey => {\n        const subOutput = deepDiffDebug(a[objKey], b[objKey], [...key, objKey])\n        output.push(...subOutput)\n        if (diffsByTypes(subOutput, [\"val\", \"ref/val\"]).length) {\n          refRow.type = \"ref/val\"\n        }\n      })\n    Object.keys(b)\n      .filter(objKey => objKey !== \"containerRef\" && !(objKey in a))\n      .sort()\n      .forEach(objKey => {\n        const subOutput = deepDiffDebug(undefined, b[objKey], [...key, objKey])\n        output.push(...subOutput)\n        if (diffsByTypes(subOutput, [\"val\", \"ref/val\"]).length) {\n          refRow.type = \"ref/val\"\n        }\n      })\n    // if we have an object type which has no keys (I'm looking at you, Date!), then we must assume that the value is different.\n    if (Object.keys(a).length === 0 && Object.keys(b).length === 0) {\n      refRow.type = \"val\"\n    }\n  } else if (objectType(a) === \"date\" && objectType(b) === \"date\") {\n    // dates are a special case. Inevitably the first of many. We look up the \"real\" type of the object\n    // (type of just reports \"object\"), and if it's a date then we note that the ref is different and compare\n    // the time values. If those differ, it's a value difference. If not, it's a ref difference.\n    output.push(refRow)\n    if (a.getTime() !== b.getTime()) {\n      refRow.type = \"val\"\n    }\n  } else {\n    output.push({\n      key,\n      leftLabel: \"left val\",\n      leftValue: a,\n      rightLabel: \"right val\",\n      rightValue: b,\n      type: \"val\"\n    })\n  }\n\n  return output\n}\n\n/*\n  internal function - given an object, returns its \"real\" type. since typeof will happily say\n  \"object\" no matter what. Right now it only handles dates, but inevitably will need to handle more.\n*/\nfunction objectType(obj) {\n  const reportedType = typeof obj\n  if (reportedType !== \"object\") {\n    return reportedType\n  } else if (Object.prototype.toString.call(obj) === \"[object Date]\") {\n    return \"date\"\n  } else {\n    return reportedType\n  }\n}\n\n/*\n  call it on the result of deepDiffDebug with an array of flags of either \"ref\", \"val\", or \"ref/val\" to filter\n  on only diffs of that type.\n\n  diffsByTypes( deepDiffDebug( obj1, obj2 ), [\"ref\"] )\n*/\n\nexport function diffsByTypes(diff, types) {\n  return diff.filter(row =>\n    types.reduce((match, type) => match || row.type === type, false)\n  )\n}\n\n/*\n  call on the result of deepDiffDebug to see if the two objects are deep equal.\n\n  isEqual( deepDiffDebug( obj1, obj2 ) )\n\n  PLEASE NOTE - there are other deep equality libraries such as\n  import deepEquals from \"fast-deep-equal\"\n\n  that are going to be faster/better. You should only use this isEqual if you want\n  the deepDiffDebug output anyway, and still want to check a boolean value at the end.\n*/\n\nexport function isEqual(diff) {\n  return diffsByTypes(diff, [\"val\"]).length === 0\n}\n\n/*\n  a deepDiff will potentially include many useless keys you don't need to check. Let's say you're diffing\n  two objects:\n    const a = {a : 1, b : { c : 3} }\n    const b = {a : 1, b : { c : 3} }\n\n  These two objects are obviously the same. the deepDiff will contain (as output via outputDeeDiff):\n\n  / : [ref] left ref !== right ref\n  b : [ref] left ref !== right ref\n\n  Showing that the root object is different AND the \"b\" key object is different. But you don't care about \"b\"\n  being a different ref - if we sanitize the objects together at the root, that'll automatically bring along the \"b\"\n  key.\n\n  The filter reduces it so the diff only includes the highest \"ref\" key in a path:\n\n  outputDeepDiff ( filterRedundantRows( deepDiffDebug( a, b) ) )\n    / : [ref] left ref !== right ref\n\n  So you can only deal with sanitizing objects once, instead of redundantly checking to sanitize other keys.\n\n*/\n\nexport function filterRedundantRows(diff) {\n  const priorKeys = []\n\n  return diff.filter(row => {\n    // if the diff is not ref, then we have to included it no matter what.\n    if (row.type !== \"ref\") {\n      return true\n    }\n\n    const rowKey = row.key.join(\"/\")\n    for (const key of priorKeys) {\n      // check all known prior keys. And if any of them match, then we're already going\n      // to get caught by that parent key. We can fail out.\n      if (rowKey.match(key)) {\n        return false\n      }\n    }\n    // if we've reached this point, then it's a ref diff AND it's not filtered by a parent\n    // so we need to included it AND we want to add its key as a prior key.\n\n    priorKeys.push(new RegExp(`^${rowKey}`))\n    return true\n  })\n}\n\n/*\n  outputDeepDiff takes a diff and an optional object of values. It will spit out the diff\n  to your console.\n\n  outputDeepDiff( deepDiffDebug( obj1, obj2 ) , options )\n\n  options may contain the following keys:\n    filter = a regex to filter the key paths.\n    withValues = true/false - print out the value of the diff in addition to the label\n    groupName = console statements will be grouped. This is the group name. defaults to\n                \"Deep Diff Output\"\n*/\n\nexport function outputDeepDiff(\n  res,\n  { filter = /.*/, withValues = false, groupName = \"Deep Diff Output\" } = {}\n) {\n  /* eslint-disable-next-line no-console */ /* tslint:disable-next-line:no-console */\n  console.groupCollapsed(groupName)\n  if (res.length === 0) {\n    /* eslint-disable-next-line no-console */ /* tslint:disable-next-line:no-console */\n    console.log(\"Objects are the same or differences are filtered out\")\n  } else {\n    res.forEach(row => {\n      const key = row.key.join(\"/\") || \"/\"\n      if (key.match(filter)) {\n        // tslint:disable\"\"\"\"\n        /* eslint-disable-next-line no-console */\n        console.log(\n          \"%s : [%s] %s !== %s\",\n          key,\n          row.type,\n          row.leftLabel,\n          row.rightLabel,\n          withValues ? row.leftValue : \"\",\n          withValues ? row.rightValue : \"\"\n        )\n        // tslint:enable\n      }\n    })\n  } /* eslint-disable-next-line no-console */\n  /* tslint:disable-next-line:no-console */ console.groupEnd(groupName)\n}\n","/*\n\n  This works in conjunction with deepDiffDebug to sanitize an object so it matches a source as closely as possible.\n\n  Let's say you have two objects:\n\n  objA = { a : 1, { b : 2 } }\n  objB = { a : 1, { b : 2 } }\n\n  These objects have value equality, but not referential equality. If you sanitize them:\n\n  const sanitized = sanitize(objA, objB);\n\n  You'll end up with:\n\n  sanitized = {a : 1, {b : 2}}\n\n  But sanitized will also === objB.\n\n  Let's say it's these two objects:\n  objA = { a : 1, { b : 2 } }\n  objB = { a : 2, { b : 2 } }\n\n  const sanitized = sanitize(objA, objB);\n\n  You'll end up with:\n\n  sanitized = {a : 1, {b : 2}}\n\n  and sanitized.b === objB.b.\n\n  Basically, it'll move args right to left if they're referentially identical.\n  If any subpath in objA is referentially equal to the same path in objB, it'll take objB's instead.\n\n  You can also give sanitize an optional 3rd argument - an options hash.\n\n   troubleMakers : an array of paths to check. If this is handed in, you can use it to reduce the comparisons by not\n   doing a full deepDiffDebug on the props and instead only target the things you know to be problematic. Should be\n   an array of path strings (not arrays)\n\n   outputSanitizedProps : boolean which'll determine if we console.log() out the props getting sanitized.\n\n   formatSanitizedProp : you probably don't need to override this, but it's a function call to provide prettier info on the\n   prop being sanitized.\n\n*/\n\nimport deepEquals from \"fast-deep-equal\"\nimport {\n  deepDiffDebug,\n  diffsByTypes,\n  filterRedundantRows\n} from \"./deepDiffDebug\"\n\nconst getValueAtPath = (obj, path) => {\n  let subObj = obj\n  for (const segment of path) {\n    if (segment in subObj) {\n      subObj = subObj[segment]\n    } else {\n      return undefined\n    }\n  }\n\n  return subObj\n}\n\nconst setValueAtPath = (obj, path, val) => {\n  if (!path.length) {\n    return val\n  }\n\n  const reducedPath = [...path]\n  const masterKey = reducedPath.pop()\n\n  const parent = getValueAtPath(obj, reducedPath)\n  parent[masterKey] = val\n\n  return obj\n}\n\nconst shouldSanitize = (objA, objB, needsDeepCheck) => {\n  // if the objects are referentially equal, we don't need to santize\n  if (objA === objB) {\n    return false\n  } else if (needsDeepCheck) {\n    // otherwise, they're not equal. If we have not performed a deep equality check,\n    // then do so now\n    return deepEquals(objA, objB)\n  } else {\n    // otherwise, they're not equal AND we have performed a deep equality check.\n    // we know it needs to be sanitized.\n    return true\n  }\n}\n\nconst defaultOptions = {\n  troubleMakers: [],\n  outputSanitizedProps: true,\n  formatSanitizedProp: (props, path) => path.join(\"/\")\n}\n\nexport const sanitize = (props, currentProps, givenOptions) => {\n  const options = { ...defaultOptions, ...givenOptions }\n  let sanitizedProps = { ...props }\n\n  const [pathsToCheck, needsDeepCheck] = options.troubleMakers.length\n    ? [options.troubleMakers.map(path => path.split(\"/\")), true]\n    : [\n        filterRedundantRows(\n          diffsByTypes(deepDiffDebug(props, currentProps), [\"ref\"]).map(\n            row => row.key\n          )\n        ),\n        false\n      ]\n\n  if (Object.keys(currentProps).length) {\n    pathsToCheck.forEach(path => {\n      const newProp = getValueAtPath(sanitizedProps, path)\n      const oldProp = getValueAtPath(currentProps, path)\n      if (shouldSanitize(newProp, oldProp, needsDeepCheck)) {\n        if (options.outputSanitizedProps) {\n          // eslint-disable-next-line\n          console.log(\"sanitizes \", options.formatSanitizedProp(props, path))\n        }\n        sanitizedProps = setValueAtPath(sanitizedProps, path, oldProp)\n      }\n    })\n  }\n\n  return sanitizedProps\n}\n","/* Zuul is the GateKeeper. https://ghostbusters.fandom.com/wiki/Zuul\n\n   Why is this component so whimsically named? Why not just go with its original name of \"GateKeeper\"?\n   Because it shouldn't exist. I don't want it to blend into the background and people gloss over it\n   and think, \"GateKeeper. Yeah, sure. Probably a security thing.\" I *want* people to say \"WTF is that?\"\n\n   Because it should not exist.\n\n   Zuul will monitor your incoming props and sanitize them if they have value but not referential equality.\n\n   So this:\n\n   export SomeComponent\n\n   becomes:\n\n   export Zuul(SomeComponent, options)\n\n   Zuul is great to wedge between a managed container and an unmanaged component.\n\n   mapStateToProps( state, actions)( Zuul(SomeComponent, options) )\n\n   The second arg to Zuul is an options hash:\n\n   enabled : true/false - whether Zuul is enabled for this component. You should -never- pass true, since that's\n   the default and we want to use that to globally turn Zuul off. But you can hand in false to turn off on an individual\n   basis. If enabled is false, Zuul will hand back the original component.\n\n   troubleMakers : an array of paths to check. If this is handed in, you can use it to reduce the comparisons by not\n   doing a full deepDiffDebug on the props and instead only target the things you know to be problematic. Should be\n   an array of path strings (not arrays)\n\n   outputSanitizedProps : boolean which'll determine if we console.log() out the props getting sanitized.\n\n   formatSanitizedProp : you probably don't need to override this, but it's a function call to provide prettier info on the\n   prop being sanitized.\n\n   deepDiffOutputCnditional : function which'll be given the props which you can use to determin if you want to output\n   the deep diff. Useful with something like (props) => props.id === \"1\" to only output a deep diff on a single component.\n\n   A good set of options to give to Zuul is...nothing. Just use the defaults.\n\n   If your props are re-factored nicely so they are only handing in new objects if some of the value has changed, then you\n   don't need to use Zuul and it will provide no benefit to you. What a wonderful world that will be.\n\n*/\n\nimport React, { useRef } from \"react\"\n\nimport { sanitize } from \"../utils/sanitizeObject\"\nimport {\n  deepDiffDebug,\n  outputDeepDiff,\n  filterRedundantRows\n} from \"../utils/deepDiffDebug\"\n\nconst defaultOptions = {\n  enabled: true,\n  troubleMakers: [],\n  outputSanitizedProps: false,\n  deepDiffOutputConditional: () => false,\n  formatSanitizedProp: (Component, props, path) =>\n    `${displayName(Component, props)} : ${path.join(\"/\")} `\n}\n\nexport const componentName = Component =>\n  Component.displayName || Component.name || \"Unknown Component\"\n\nexport const displayName = (Component, props) =>\n  `${componentName(Component)} [${props.id || \"no id\"}]`\n\nexport default (Component, givenOptions) => {\n  const options = { ...defaultOptions, ...givenOptions }\n  const sanitizedFormatter = options.formatSanitizedProp\n  options.formatSanitizedProp = (props, path) =>\n    sanitizedFormatter(Component, props, path)\n\n  // if we're not enabled, we can safely just return the original component.\n  if (!options.enabled) {\n    return Component\n  }\n\n  return function Zuul(props) {\n    const lastProps = useRef({})\n    const currentProps = lastProps.current\n    const sanitizedProps = sanitize(props, currentProps, options, Component)\n\n    if (options.deepDiffOutputConditional(props)) {\n      outputDeepDiff(\n        filterRedundantRows(deepDiffDebug(props, currentProps), [\"ref\"]),\n        {\n          groupName: `deep diff props vs old props - ${displayName(\n            Component,\n            props\n          )}`,\n          withValues: true\n        }\n      )\n      outputDeepDiff(\n        filterRedundantRows(deepDiffDebug(sanitizedProps, currentProps)),\n        {\n          groupName: `deep diff sanitized props vs old props - ${displayName(\n            Component,\n            props\n          )}`,\n          withValues: true\n        }\n      )\n    }\n\n    lastProps.current = sanitizedProps\n    return <Component {...sanitizedProps} />\n  }\n}\n","/*\n  This is a companion to deepDiffDebug. That utility is mostly used by Zuul.\n\n  This one is mostly used by vinceclortho.\n\n  deepPathWalk will take a single object as an input and walk through it, producing\n  a list of key/value pairs in a similar style to deepDiffDebug.\n\n  const obj = {a : 1, b : 2, c : {d : 3}}\n\n  const res = deepPathWalk(obj);\n\n  res is:\n  [\n    { key : \"a\", value : 1 },\n    { key : \"b\", value : 2 },\n    { key : \"c\", value : { d : 3 } },\n    { key : \"c/d\", value : 3 }\n  ]\n\n*/\n\nexport function deepPathWalk(obj, key = [], seen = new Set()) {\n  const output = []\n\n  const refRow = {\n    key,\n    value: obj\n  }\n\n  output.push(refRow)\n\n  if ( (Array.isArray(obj) || typeof obj === \"object\") && seen.has(obj)) {\n    // already seen? bomb out early.\n    return output\n  }\n\n  seen.add(obj)\n\n  if (obj === null) {\n    // null object? DO NOTHING\n  } else if (Array.isArray(obj)) {\n    obj.forEach((e, i) => {\n      const subOutput = deepPathWalk(e, [...key, i], seen)\n      output.push(...subOutput)\n    })\n  } else if (typeof obj === \"object\") {\n    Object.keys(obj)\n      .sort()\n      .forEach(objKey => {\n        const subOutput = deepPathWalk(obj[objKey], [...key, objKey], seen)\n        output.push(...subOutput)\n      })\n  } else {\n    output.push(refRow)\n  }\n\n  return output\n}\n\n/*\n  This takes a deepWalk result and collapses it into an object instead of a list.\n*/\n\nexport function collapseDeepWalk(res) {\n  return res.reduce((collapsed, row) => {\n    collapsed[row.key.join(\"/\")] = row.value\n    return collapsed\n  }, {})\n}\n\n/*\n  given a res list, this'll filter out duplicate keypaths.\n\n  [\"c\", \"d\"] and [\"c/d\"] are the same key, and should point to the same value.\n*/\n\nexport function filterDuplicates(res) {\n  const seen = new Set()\n  return res.filter(row => {\n    const key = row.key.join(\"/\") || \"/\"\n    if (seen.has(key)) {\n      return false\n    } else {\n      seen.add(key)\n      return true\n    }\n  })\n}\n\n/*\n  given a collapsed deep walk, this'll peel out only the key/value pairs with scalar values.\n  Basically, it gets you the leaves of your walk.\n*/\n\nexport function pickScalars(obj) {\n  return Object.keys(obj).reduce((picked, objKey) => {\n    const value = obj[objKey]\n    if (\n      value === null ||\n      (!Array.isArray(value) && typeof value !== \"object\")\n    ) {\n      picked[objKey] = value\n    }\n    return picked\n  }, {})\n}\n\n/*\n  much like outputDeepDiff from deepDiffDebug, this'll output your deepWalk in a pretty format\n*/\n\nexport function outputDeepWalk(\n  res,\n  { filter = /.*/, withValues = false, groupName = \"Deep Walk Output\" } = {}\n) {\n  /* eslint-disable-next-line no-console */\n  console.groupCollapsed(groupName)\n  res.forEach(row => {\n    const key = row.key.join(\"/\") || \"/\"\n    if (key.match(filter)) {\n      /* eslint-disable-next-line no-console */\n      console.log(\"%s : %s\", key, row.value, withValues ? row.value : \"\")\n    }\n  })\n  /* eslint-disable-next-line no-console */\n  console.groupEnd(groupName)\n}\n","/*\n  vinzclortho is the key master https://ghostbusters.fandom.com/wiki/Vinz_Clortho\n\n  Honestly, Vinz may be even more powerful than Zuul. Never ~ever~ leave Vinz enabled\n  in a production environment.\n\n  Vinz here is middleware that monitors your redux store and notifies you if:\n\n  * you've mutated an object. VERY VERY BAD.\n  * you've re-packaged a value so it's logically equivalent, but a new reference.\n    Not terrible, but sloppy.\n\n  Vinz is configured with an options hash when you apply middleware, or you can use the\n  defaults.\n\n  applyMiddleware([\n    vinzclortho(options)\n  ])\n\n  options may be:\n\n  * logMutations : true/false - spits out to console if you mutate. defaults true.\n  * debugMutations : true/false - breaks to the debugger when it catches a mutation. defaults false.\n  * logRepackaging : true/false - spits out to console if you repackage. defaults false.\n  * debugRepackaging : true/false - breaks to debugger when it catches a repackage. defaults false.\n\n*/\n\nimport { deepDiffDebug, diffsByTypes } from \"../utils/deepDiffDebug\"\nimport {\n  deepPathWalk,\n  collapseDeepWalk,\n  filterDuplicates\n} from \"../utils/deepWalkDebug\"\n\nconst defaultOptions = {\n  logMutations: true,\n  logRepackaging: false,\n  debugMutations: false,\n  debugRepackaging: false\n}\n\nexport default givenOptions => {\n  const options = {\n    ...defaultOptions,\n    ...givenOptions\n  }\n\n  // tslint-disable\n  // eslint-disable-next-line\n  console.info(\n    \"VINZ CLORTHO HAS BEEN SUMMONED. YOU HAD ~BETTER~ BE IN A DEV ENVIRONMENT!\"\n  )\n  // tslint-enable\n\n  return store => next => action => {\n    // okay, here's where the magic happens. First things first - we do a deep walk of the\n    // current state and collapse it into a single object. This gives us a record of every\n    // value at every keypath - AND it maintains the original object references.\n    const oldState = collapseDeepWalk(\n      filterDuplicates(deepPathWalk(store.getState()))\n    ) /* tslint:disable-next-line */\n\n    // next, we just dispatch our current action.\n    /* eslint-disable-next-line */\n    const result = next(action)\n\n    // Now we do a deep walk of the new state after the action was fired. Same deal - we\n    // get a listing of every object at every keypath, with the original object references.\n    const newState = collapseDeepWalk(\n      filterDuplicates(deepPathWalk(store.getState()))\n    )\n\n    // now, we have two objects so we can just do a standard deepDiffDebug on them to find\n    // the differences.\n    //\n    // We care about paths that differ by \"ref\", meaning that they are object containers, but\n    // are logically equal (though not referentially equal) That indicates a re-packaging error\n    //\n    // We also care about paths that differ by \"val\", meaning that they're a scalar value that\n    // has changed. In that case, we want to look through all of their parents and see if any of\n    // those objects appear in both states - because if they do that indicates a mutation.\n    const deepDiffs = diffsByTypes(deepDiffDebug(oldState, newState), [\n      \"val\",\n      \"ref\"\n    ])\n\n    const seen = new Set()\n\n    // now we're going to iterate over the diffs.\n    deepDiffs.forEach(row => {\n      // because of the deepPathWalk output, we may have duplicate keys - [\"foo/bar\"] and [\"foo\", \"bar\"] are\n      // identical paths. So we join all subpaths and check for duplication. If nothing, we continue on and\n      // re-split to get all sub-paths.\n      const keyStr = row.key.join(\"/\")\n\n      if (seen.has(keyStr)) {\n        return\n      }\n      seen.add(keyStr)\n      const key = keyStr.split(\"/\")\n\n      // if it's a value change and we're logging mutations, we need to look at all parent containers and see if\n      // any of them have referential equality, but not value.\n      if (options.logMutations && row.type === \"val\") {\n        const subKeyRing = []\n        key.forEach(piece => {\n          subKeyRing.push(piece)\n          const subKey = subKeyRing.join(\"/\")\n          if (seen.has(subKey)) {\n            return\n          }\n\n          // if we're in here, we know a value has changed. So if the parent containers match in both states, we know that it\n          // must have been a mutation.\n          if (\n            oldState[subKey] !== undefined &&\n            newState[subKey] !== undefined\n          ) {\n            if (oldState[subKey] === newState[subKey]) {\n              seen.add(subKey)\n              // tslint-disable\n              // eslint-disable-next-line\n              console.error(\n                \"VINZ CLORTHO SAYS YOUR REDUX STORE WILL PERISH IN FLAMES. MUTATION @ \",\n                subKey || \"/\",\n                action,\n                row\n              )\n              // ts-lint-enable\n              if (options.debugMutations) {\n                /* eslint-disable-next-line no-debugger */ /* tslint:disable-next-line:no-debugger */\n                debugger\n              }\n            }\n          }\n        })\n      }\n\n      // if we're logging repackaging, then look to see if this is a \"ref\" change. That means the two objects are identical, but\n      // different refs.\n      if (options.logRepackaging) {\n        if (\n          oldState[keyStr] !== undefined &&\n          newState[keyStr] !== undefined &&\n          row.type === \"ref\"\n        ) {\n          // tslint-disable\n          // eslint-disable-next-line\n          console.warn(\n            \"VINZ CLORTHO SAYS YOUR REDUX STORE IS NOT IN ONE OF THE PRE-CHOSEN FORMS. UNNECESSARY RE-PACKAGING @ \",\n            keyStr,\n            action\n          )\n          // tslint-enable\n        }\n        if (options.debugRepackaging) {\n          /* eslint-disable-next-line no-debugger */ /* tslint:disable-next-line:no-debugger */\n          debugger\n        }\n      }\n    })\n\n    return result\n  }\n}\n"],"names":["deepDiffDebug","a","b","key","output","refRow","Array","isArray","push","forEach","e","i","subOutput","diffsByTypes","length","type","undefined","objectType","keys","filter","objKey","sort","Object","getTime","obj","reportedType","prototype","toString","call","diff","types","reduce","match","row","isEqual","filterRedundantRows","priorKeys","rowKey","join","RegExp","outputDeepDiff","res","withValues","groupName","groupCollapsed","log","leftLabel","rightLabel","leftValue","rightValue","console","groupEnd","getValueAtPath","path","subObj","segment","setValueAtPath","val","reducedPath","masterKey","pop","parent","shouldSanitize","objA","objB","needsDeepCheck","deepEquals","defaultOptions","props","sanitize","currentProps","givenOptions","options","sanitizedProps","troubleMakers","map","split","pathsToCheck","newProp","oldProp","outputSanitizedProps","formatSanitizedProp","Component","displayName","componentName","name","id","sanitizedFormatter","enabled","Zuul","lastProps","useRef","current","deepDiffOutputConditional","React","deepPathWalk","seen","Set","has","add","collapseDeepWalk","collapsed","value","filterDuplicates","pickScalars","picked","outputDeepWalk","info","oldState","store","getState","result","next","action","newState","deepDiffs","keyStr","logMutations","subKeyRing","piece","subKey","error","debugMutations","logRepackaging","warn","debugRepackaging"],"mappings":"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"}